/**
 * Script para testar especificamente o webhook da Hotmart com o ID de produto 5381714 
 * e c√≥digo de oferta aukjngrt
 * 
 * Este script simula um webhook da Hotmart com dados reais para validar
 * o funcionamento do mapeamento de produtos.
 */

import fetch from 'node-fetch';
import { PrismaClient } from '@prisma/client';
import dotenv from 'dotenv';

dotenv.config();

const prisma = new PrismaClient();

// Fun√ß√£o para simular um evento de compra da Hotmart
async function simulateSpecificHotmartWebhook() {
  console.log('\nüöÄ Iniciando teste de webhook espec√≠fico da Hotmart...');
  console.log('üìã Usando: Product ID: 5381714, Offer Code: aukjngrt');
  
  // Gera um email de teste √∫nico para facilitar o rastreamento
  const testEmail = `teste.${Date.now()}@designauto.com.br`;
  
  // Payload de exemplo de uma compra aprovada com os dados espec√≠ficos
  const payload = {
    data: {
      purchase: {
        transaction: 'TXTEST-' + Date.now(),
        status: 'APPROVED',
        offer: {
          code: 'aukjngrt' // C√≥digo da oferta espec√≠fica
        },
        subscription: {
          subscriber: {
            code: 'SUBTEST-' + Math.floor(Math.random() * 100000),
            email: testEmail,
            name: 'Usu√°rio de Teste'
          },
          plan: {
            name: 'Plano Anual DesignAuto'
          },
          status: 'ACTIVE',
          recurrenceNumber: 1,
          accession: {
            date: new Date().toISOString()
          }
        }
      },
      product: {
        id: '5381714', // ID do produto espec√≠fico na Hotmart
        name: 'DesignAuto Premium'
      }
    },
    event: 'PURCHASE_APPROVED',
    id: 'webhook-specific-test-' + Date.now(),
    creationDate: new Date().toISOString()
  };

  // Token de webhook da Hotmart
  const webhookToken = process.env.HOTMART_WEBHOOK_SECRET || 'teste-secreto';

  try {
    // 1. Verificar o mapeamento de produtos na tabela
    await checkProductMapping('5381714', 'aukjngrt');
    
    // 2. Enviar o webhook simulado para o endpoint
    console.log('\nüì¶ Enviando webhook simulado para o servidor...');
    const response = await fetch('http://localhost:5000/api/webhooks/hotmart', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-hotmart-hottok': webhookToken
      },
      body: JSON.stringify(payload)
    });

    const result = await response.json();
    console.log('üì¨ Resposta do servidor:', result);

    // 3. Verificar se o log foi registrado no banco
    console.log('\nüîç Verificando logs no banco de dados...');
    await checkWebhookLogs(testEmail);
    
    // 4. Verificar se o usu√°rio foi criado ou atualizado no banco
    console.log('\nüë§ Verificando se a assinatura do usu√°rio foi atualizada...');
    await checkUserSubscription(testEmail);
    
  } catch (error) {
    console.error('‚ùå Erro ao simular webhook espec√≠fico:', error);
  }
}

// Fun√ß√£o para verificar o mapeamento de produtos no banco
async function checkProductMapping(productId, offerId) {
  console.log(`\nüîç Verificando mapeamento para: Product ID ${productId}, Offer ID ${offerId}`);
  
  try {
    // Verificar primeiro se a tabela existe
    const tablesResult = await prisma.$queryRaw`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'hotmart_product_mappings'
      );
    `;
    
    const tableExists = tablesResult[0].exists;
    
    if (!tableExists) {
      console.log('‚ö†Ô∏è A tabela hotmart_product_mappings n√£o existe!');
      console.log('Criando tabela e adicionando mapeamento...');
      
      // Criar tabela se n√£o existir
      await prisma.$executeRaw`
        CREATE TABLE hotmart_product_mappings (
          id SERIAL PRIMARY KEY,
          product_id VARCHAR(50) NOT NULL,
          offer_id VARCHAR(50),
          plan_type VARCHAR(50) NOT NULL,
          days_valid INTEGER NOT NULL,
          active BOOLEAN DEFAULT true,
          created_at TIMESTAMP NOT NULL DEFAULT NOW(),
          updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
          UNIQUE(product_id, offer_id)
        );
      `;
      
      // Inserir mapeamento do produto espec√≠fico
      await prisma.$executeRaw`
        INSERT INTO hotmart_product_mappings 
        (product_id, offer_id, plan_type, days_valid, active)
        VALUES 
        (${productId}, ${offerId}, 'anual', 365, true);
      `;
      
      console.log('‚úÖ Tabela e mapeamento criados com sucesso!');
    } else {
      console.log('‚úÖ Tabela hotmart_product_mappings existe!');
      
      // Verificar se o mapeamento existe
      const mappingResult = await prisma.$queryRaw`
        SELECT * FROM hotmart_product_mappings
        WHERE product_id = ${productId}
        AND (offer_id = ${offerId} OR offer_id IS NULL)
        AND active = true;
      `;
      
      if (mappingResult && mappingResult.length > 0) {
        console.log('‚úÖ Mapeamento encontrado:', mappingResult);
      } else {
        console.log('‚ö†Ô∏è Mapeamento n√£o encontrado. Adicionando...');
        
        // Inserir mapeamento
        await prisma.$executeRaw`
          INSERT INTO hotmart_product_mappings 
          (product_id, offer_id, plan_type, days_valid, active)
          VALUES 
          (${productId}, ${offerId}, 'anual', 365, true)
          ON CONFLICT (product_id, offer_id) 
          DO UPDATE SET
            active = true,
            plan_type = 'anual',
            days_valid = 365,
            updated_at = NOW();
        `;
        
        console.log('‚úÖ Mapeamento adicionado com sucesso!');
      }
    }
  } catch (error) {
    console.error('‚ùå Erro ao verificar/criar mapeamento:', error);
  }
}

// Fun√ß√£o para verificar os logs de webhook no banco
async function checkWebhookLogs(email) {
  try {
    // Buscar logs recentes relacionados a este email
    const logs = await prisma.$queryRaw`
      SELECT * FROM webhook_logs 
      WHERE email = ${email} 
      ORDER BY created_at DESC 
      LIMIT 5
    `;
    
    if (logs && logs.length > 0) {
      console.log('‚úÖ Logs de webhook encontrados:');
      console.table(logs.map(log => ({
        id: log.id,
        data: new Date(log.created_at).toLocaleString(),
        evento: log.event_type,
        status: log.status,
        email: log.email
      })));
    } else {
      console.log('‚ùå Nenhum log encontrado para este email:', email);
      console.log('‚ö†Ô∏è Verificando todos os logs recentes...');
      
      // Buscar todos os logs recentes
      const allLogs = await prisma.$queryRaw`
        SELECT * FROM webhook_logs 
        ORDER BY created_at DESC 
        LIMIT 10
      `;
      
      if (allLogs && allLogs.length > 0) {
        console.log('‚ÑπÔ∏è Logs recentes encontrados:');
        console.table(allLogs.map(log => ({
          id: log.id,
          data: new Date(log.created_at).toLocaleString(),
          evento: log.event_type,
          email: log.email || 'N/A',
          status: log.status
        })));
      } else {
        console.log('‚ùå Nenhum log recente encontrado na tabela webhook_logs');
      }
    }
  } catch (error) {
    console.error('‚ùå Erro ao verificar logs:', error);
  }
}

// Fun√ß√£o para verificar se a assinatura do usu√°rio foi atualizada
async function checkUserSubscription(email) {
  try {
    const user = await prisma.users.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        tipoplano: true,
        origemassinatura: true,
        dataassinatura: true,
        dataexpiracao: true
      }
    });
    
    if (user) {
      console.log('‚úÖ Usu√°rio encontrado com assinatura:');
      console.table([{
        id: user.id,
        email: user.email,
        plano: user.tipoplano || 'N/A',
        origem: user.origemassinatura || 'N/A',
        inicio: user.dataassinatura ? new Date(user.dataassinatura).toLocaleString() : 'N/A',
        expiracao: user.dataexpiracao ? new Date(user.dataexpiracao).toLocaleString() : 'N/A'
      }]);
      
      // Verificar se o plano est√° correto (anual)
      if (user.tipoplano === 'anual' || user.tipoplano === 'premium') {
        console.log('‚úÖ Plano atualizado corretamente para anual/premium!');
      } else {
        console.log('‚ùå Plano N√ÉO foi atualizado corretamente. Valor atual:', user.tipoplano);
      }
      
      // Verificar a data de expira√ß√£o (deve ser cerca de 1 ano no futuro)
      if (user.dataexpiracao) {
        const oneYearInMs = 365 * 24 * 60 * 60 * 1000;
        const now = new Date();
        const expiryDate = new Date(user.dataexpiracao);
        const diffInDays = Math.round((expiryDate - now) / (24 * 60 * 60 * 1000));
        
        if (diffInDays > 350) { // Aproximadamente 1 ano com pequena margem
          console.log('‚úÖ Data de expira√ß√£o correta (aproximadamente 1 ano):', diffInDays, 'dias');
        } else {
          console.log('‚ùå Data de expira√ß√£o incorreta. Dias restantes:', diffInDays);
        }
      } else {
        console.log('‚ùå Data de expira√ß√£o n√£o definida');
      }
    } else {
      console.log('‚ùå Usu√°rio com email', email, 'n√£o encontrado no banco');
      console.log('‚ö†Ô∏è O usu√°rio deveria ter sido criado automaticamente pelo webhook');
      
      // Verificar se h√° algum usu√°rio com email semelhante
      const similarUsers = await prisma.users.findMany({
        where: {
          email: {
            contains: email.split('@')[0]
          }
        },
        select: {
          id: true,
          email: true,
          tipoplano: true
        },
        take: 5
      });
      
      if (similarUsers.length > 0) {
        console.log('‚ÑπÔ∏è Usu√°rios com email semelhante encontrados:');
        console.table(similarUsers);
      }
    }
  } catch (error) {
    console.error('‚ùå Erro ao verificar assinatura do usu√°rio:', error);
  }
}

// Fun√ß√£o principal
async function main() {
  console.log('\nüîß Iniciando teste espec√≠fico com dados reais do webhook Hotmart');
  console.log('üìä Product ID: 5381714, Offer Code: aukjngrt');
  
  try {
    // Verificar se as tabelas necess√°rias existem
    await checkRequiredTables();
    
    // Simular o webhook espec√≠fico
    await simulateSpecificHotmartWebhook();
    
    console.log('\n‚úÖ Teste conclu√≠do!');
  } catch (error) {
    console.error('\n‚ùå Erro ao executar o teste:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// Verificar se as tabelas necess√°rias existem
async function checkRequiredTables() {
  const requiredTables = [
    'webhook_logs',
    'hotmart_product_mappings',
    'users'
  ];
  
  console.log('\nüîç Verificando tabelas necess√°rias...');
  
  for (const tableName of requiredTables) {
    try {
      const result = await prisma.$queryRaw`
        SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_name = ${tableName}
        );
      `;
      
      const exists = result[0]?.exists;
      
      if (exists) {
        console.log(`‚úÖ Tabela ${tableName} existe`);
      } else {
        console.log(`‚ùå Tabela ${tableName} N√ÉO existe!`);
      }
    } catch (error) {
      console.error(`‚ùå Erro ao verificar tabela ${tableName}:`, error);
    }
  }
}

// Executar o script
main().catch(e => {
  console.error('‚ùå Erro fatal:', e);
  process.exit(1);
});