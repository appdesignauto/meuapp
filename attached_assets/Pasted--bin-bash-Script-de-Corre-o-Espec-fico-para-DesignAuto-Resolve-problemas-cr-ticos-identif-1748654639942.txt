#!/bin/bash

# Script de Corre√ß√£o Espec√≠fico para DesignAuto
# Resolve problemas cr√≠ticos identificados na an√°lise

echo "üöÄ CORRE√á√ÉO AUTOM√ÅTICA - PROJETO DESIGNAUTO"
echo "==========================================="
echo ""

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Backup de seguran√ßa antes das corre√ß√µes
create_backup() {
    echo -e "${BLUE}üì¶ Criando backup de seguran√ßa...${NC}"
    backup_dir="backup_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"
    
    # Backup dos arquivos importantes antes das mudan√ßas
    [ -f ".env" ] && cp .env "$backup_dir/"
    [ -f ".gitignore" ] && cp .gitignore "$backup_dir/"
    [ -f "package.json" ] && cp package.json "$backup_dir/"
    
    echo "‚úÖ Backup criado em: $backup_dir"
    echo ""
}

# üî¥ CR√çTICO: Proteger arquivo .env
fix_env_security() {
    echo -e "${RED}üîí CORRIGINDO PROBLEMA CR√çTICO DE SEGURAN√áA...${NC}"
    
    # Verificar se .env existe
    if [ -f ".env" ]; then
        echo "üìÑ Arquivo .env encontrado"
        
        # Verificar se .gitignore existe, sen√£o criar
        if [ ! -f ".gitignore" ]; then
            echo "üìù Criando arquivo .gitignore"
            touch .gitignore
        fi
        
        # Adicionar .env ao .gitignore se n√£o estiver l√°
        if ! grep -q "^\.env$" .gitignore 2>/dev/null; then
            echo "" >> .gitignore
            echo "# Environment variables" >> .gitignore
            echo ".env" >> .gitignore
            echo ".env.local" >> .gitignore
            echo ".env.development.local" >> .gitignore
            echo ".env.test.local" >> .gitignore
            echo ".env.production.local" >> .gitignore
            echo "‚úÖ .env adicionado ao .gitignore"
        else
            echo "‚úÖ .env j√° est√° protegido no .gitignore"
        fi
        
        # Verificar se .env j√° foi commitado
        if git ls-files --error-unmatch .env >/dev/null 2>&1; then
            echo ""
            echo -e "${YELLOW}‚ö†Ô∏è  ATEN√á√ÉO: .env j√° foi commitado no Git!${NC}"
            echo "Execute manualmente:"
            echo "git rm --cached .env"
            echo "git commit -m 'Remove .env from tracking'"
            echo ""
        fi
        
        # Criar .env.example como template
        if [ ! -f ".env.example" ]; then
            echo "üìã Criando .env.example como template..."
            sed 's/=.*/=/' .env > .env.example 2>/dev/null || echo "# Environment variables template" > .env.example
            echo "‚úÖ .env.example criado"
        fi
    else
        echo "‚ÑπÔ∏è  Arquivo .env n√£o encontrado"
    fi
    echo ""
}

# üü° Remover arquivos desnecess√°rios
cleanup_unnecessary_files() {
    echo -e "${YELLOW}üóëÔ∏è  REMOVENDO ARQUIVOS DESNECESS√ÅRIOS...${NC}"
    
    files_removed=0
    
    # Remover arquivos .bak
    bak_files=$(find . -name "*.bak" -type f ! -path "./node_modules/*" ! -path "./.git/*")
    if [ ! -z "$bak_files" ]; then
        echo "üîÑ Removendo arquivos .bak:"
        echo "$bak_files" | while read file; do
            echo "   Removendo: $file"
            rm -f "$file"
        done
        files_removed=$((files_removed + $(echo "$bak_files" | wc -l)))
    fi
    
    # Remover logs antigos
    old_logs=$(find . -name "*.log" -type f ! -path "./node_modules/*" ! -path "./.git/*" -mtime +7)
    if [ ! -z "$old_logs" ]; then
        echo "üìú Removendo logs antigos (>7 dias):"
        echo "$old_logs" | while read file; do
            echo "   Removendo: $file"
            rm -f "$file"
        done
        files_removed=$((files_removed + $(echo "$old_logs" | wc -l)))
    fi
    
    # Remover arquivos tempor√°rios
    temp_files=$(find . \( -name "*.tmp" -o -name "*.temp" -o -name "*~" \) -type f ! -path "./node_modules/*" ! -path "./.git/*")
    if [ ! -z "$temp_files" ]; then
        echo "üóÇÔ∏è  Removendo arquivos tempor√°rios:"
        echo "$temp_files" | while read file; do
            echo "   Removendo: $file"
            rm -f "$file"
        done
        files_removed=$((files_removed + $(echo "$temp_files" | wc -l)))
    fi
    
    # Cache do TypeScript
    if [ -d ".tsc-cache" ]; then
        echo "üßπ Limpando cache TypeScript..."
        rm -rf .tsc-cache
        files_removed=$((files_removed + 1))
    fi
    
    echo "‚úÖ $files_removed arquivos/pastas removidos"
    echo ""
}

# üü° Otimizar imagens grandes
optimize_images() {
    echo -e "${YELLOW}üñºÔ∏è  ANALISANDO IMAGENS GRANDES...${NC}"
    
    # Encontrar imagens grandes em attached_assets
    large_images=$(find ./attached_assets -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.gif" \) -size +1M 2>/dev/null)
    
    if [ ! -z "$large_images" ]; then
        echo "üì∏ Imagens grandes encontradas em attached_assets/:"
        echo "$large_images" | while read img; do
            size=$(du -h "$img" | cut -f1)
            echo "   ‚Ä¢ $(basename "$img") - $size"
        done
        
        echo ""
        echo "üí° Recomenda√ß√µes para otimiza√ß√£o:"
        echo "   1. Use ferramentas como TinyPNG ou ImageOptim"
        echo "   2. Considere WebP para melhor compress√£o"
        echo "   3. Implemente lazy loading para imagens grandes"
        echo "   4. Use CDN para servir assets est√°ticos"
    else
        echo "‚úÖ Nenhuma imagem muito grande encontrada"
    fi
    echo ""
}

# üü¢ An√°lise de depend√™ncias
analyze_dependencies() {
    echo -e "${GREEN}üì¶ ANALISANDO DEPEND√äNCIAS...${NC}"
    
    if [ -f "package.json" ]; then
        # Verificar se npm est√° dispon√≠vel
        if command -v npm &> /dev/null; then
            echo "üîç Verificando vulnerabilidades..."
            npm audit --audit-level=moderate 2>/dev/null | head -20
            
            echo ""
            echo "üßπ Para limpar depend√™ncias n√£o utilizadas, execute:"
            echo "   npm install --package-lock-only"
            echo "   npx depcheck (para encontrar depend√™ncias n√£o utilizadas)"
        fi
        
        # Verificar packages duplicados no package.json
        if command -v jq &> /dev/null; then
            deps=$(jq -r '.dependencies // {} | keys[]' package.json 2>/dev/null)
            dev_deps=$(jq -r '.devDependencies // {} | keys[]' package.json 2>/dev/null)
            
            duplicates=$(echo -e "$deps\n$dev_deps" | sort | uniq -d)
            if [ ! -z "$duplicates" ]; then
                echo "‚ö†Ô∏è  Depend√™ncias duplicadas encontradas:"
                echo "$duplicates" | sed 's/^/   ‚Ä¢ /'
            fi
        fi
    fi
    echo ""
}

# üü¢ Limpeza de console.log para produ√ß√£o
cleanup_console_logs() {
    echo -e "${GREEN}üêõ IDENTIFICANDO console.log PARA PRODU√á√ÉO...${NC}"
    
    # Procurar console.log em arquivos TypeScript/JavaScript
    console_logs=$(find . \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) ! -path "./node_modules/*" ! -path "./.git/*" -exec grep -l "console\.log" {} \; 2>/dev/null)
    
    if [ ! -z "$console_logs" ]; then
        total_logs=$(find . \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) ! -path "./node_modules/*" ! -path "./.git/*" -exec grep -c "console\.log" {} \; 2>/dev/null | awk '{sum += $1} END {print sum}')
        
        echo "üìä $total_logs console.log encontrados em:"
        echo "$console_logs" | head -10 | sed 's/^/   ‚Ä¢ /'
        
        if [ $(echo "$console_logs" | wc -l) -gt 10 ]; then
            echo "   ... e mais $(( $(echo "$console_logs" | wc -l) - 10 )) arquivos"
        fi
        
        echo ""
        echo "üí° Para remover automaticamente (CUIDADO!):"
        echo "   find . -name '*.ts' -o -name '*.tsx' -o -name '*.js' -o -name '*.jsx' | xargs sed -i '/console\.log/d'"
        echo ""
        echo "‚ö†Ô∏è  Recomendado: Revisar manualmente ou usar linter para remover"
    else
        echo "‚úÖ Nenhum console.log encontrado"
    fi
    echo ""
}

# Atualizar .gitignore com melhores pr√°ticas
update_gitignore() {
    echo -e "${BLUE}üìù ATUALIZANDO .GITIGNORE...${NC}"
    
    # Template completo para projeto React/Node.js
    gitignore_additions="
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Dependency directories
node_modules/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
public

# Storybook build outputs
.out
.storybook-out

# Temporary folders
tmp/
temp/

# Editor directories and files
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Build outputs
build/
dist/

# TypeScript cache
*.tsbuildinfo

# ESLint cache
.eslintcache
"

    # Verificar quais linhas j√° existem
    existing_lines=0
    if [ -f ".gitignore" ]; then
        existing_lines=$(wc -l < .gitignore)
    fi
    
    # Adicionar apenas linhas que n√£o existem
    echo "$gitignore_additions" | while read line; do
        if [ ! -z "$line" ] && [ "${line:0:1}" != "#" ]; then
            if ! grep -Fxq "$line" .gitignore 2>/dev/null; then
                echo "$line" >> .gitignore
            fi
        elif [ ! -z "$line" ] && [ "${line:0:1}" = "#" ]; then
            echo "$line" >> .gitignore
        fi
    done
    
    new_lines=$(wc -l < .gitignore)
    added_lines=$((new_lines - existing_lines))
    
    echo "‚úÖ .gitignore atualizado (+$added_lines linhas)"
    echo ""
}

# Gerar relat√≥rio de melhorias
generate_report() {
    echo -e "${GREEN}üìã RELAT√ìRIO DE CORRE√á√ïES APLICADAS${NC}"
    echo "==================================="
    echo ""
    
    echo "‚úÖ CORRE√á√ïES REALIZADAS:"
    echo "   ‚Ä¢ Arquivo .env protegido no .gitignore"
    echo "   ‚Ä¢ Arquivos desnecess√°rios removidos"
    echo "   ‚Ä¢ .gitignore atualizado com melhores pr√°ticas"
    echo "   ‚Ä¢ An√°lise de depend√™ncias executada"
    echo "   ‚Ä¢ console.log identificados para revis√£o"
    echo ""
    
    echo "üìã PR√ìXIMOS PASSOS MANUAIS:"
    echo "   1. Revisar e remover console.log para produ√ß√£o"
    echo "   2. Executar 'npm audit fix' para corrigir vulnerabilidades"
    echo "   3. Otimizar imagens grandes identificadas"
    echo "   4. Verificar se .env foi commitado anteriormente"
    echo ""
    
    echo "üîÑ COMANDOS √öTEIS PARA MANUTEN√á√ÉO:"
    echo "   npm run build          # Testar build"
    echo "   npm audit              # Verificar seguran√ßa"
    echo "   npx depcheck           # Depend√™ncias n√£o utilizadas"
    echo "   git status             # Verificar mudan√ßas"
    echo ""
    
    echo "‚ö° DICAS DE PERFORMANCE:"
    echo "   ‚Ä¢ Configure Webpack Bundle Analyzer"
    echo "   ‚Ä¢ Implemente code splitting"
    echo "   ‚Ä¢ Use lazy loading para componentes pesados"
    echo "   ‚Ä¢ Configure cache HTTP para assets"
    echo ""
}

# Verifica√ß√£o final
final_verification() {
    echo -e "${BLUE}üîç VERIFICA√á√ÉO FINAL...${NC}"
    
    # Verificar se .env est√° no .gitignore
    if grep -q "^\.env$" .gitignore 2>/dev/null; then
        echo "‚úÖ .env est√° protegido"
    else
        echo "‚ùå .env ainda n√£o est√° protegido"
    fi
    
    # Verificar arquivos grandes remanescentes
    large_files=$(find . -type f -size +5M ! -path "./node_modules/*" ! -path "./.git/*" ! -path "./backup_*/*" 2>/dev/null | wc -l)
    echo "üìä Arquivos grandes (>5MB): $large_files"
    
    # Status do Git
    if command -v git &> /dev/null && git rev-parse --git-dir >/dev/null 2>&1; then
        unstaged=$(git diff --name-only | wc -l)
        staged=$(git diff --cached --name-only | wc -l)
        echo "üìù Arquivos modificados: $unstaged n√£o staged, $staged staged"
    fi
    
    echo ""
}

# Executar todas as corre√ß√µes
main() {
    echo "Iniciando corre√ß√µes para o projeto DesignAuto..."
    echo "Este script vai:"
    echo "‚Ä¢ Criar backup de seguran√ßa"
    echo "‚Ä¢ Corrigir problemas de seguran√ßa"
    echo "‚Ä¢ Limpar arquivos desnecess√°rios"
    echo "‚Ä¢ Otimizar configura√ß√µes"
    echo ""
    
    read -p "Continuar? (y/N): " -n 1 -r
    echo ""
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        create_backup
        fix_env_security
        cleanup_unnecessary_files
        optimize_images
        analyze_dependencies
        cleanup_console_logs
        update_gitignore
        generate_report
        final_verification
        
        echo -e "${GREEN}üéâ CORRE√á√ïES CONCLU√çDAS COM SUCESSO!${NC}"
        echo "Verifique o relat√≥rio acima e execute os pr√≥ximos passos manuais."
    else
        echo "Opera√ß√£o cancelada."
    fi
}

# Executar se chamado diretamente
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi