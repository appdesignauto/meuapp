#!/bin/bash

# Script de An√°lise Inteligente para Aplica√ß√µes Replit
# Detecta erros, bugs, arquivos desnecess√°rios, problemas de seguran√ßa e otimiza√ß√µes

echo "üîç INICIANDO AN√ÅLISE INTELIGENTE DA APLICA√á√ÉO..."
echo "=================================================="
echo ""

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Fun√ß√£o para detectar tipo de projeto
detect_project_type() {
    echo -e "${BLUE}üìã DETECTANDO TIPO DE PROJETO...${NC}"
    
    if [ -f "package.json" ]; then
        echo "‚úì Projeto Node.js/JavaScript detectado"
        PROJECT_TYPE="nodejs"
    elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ] || [ -f "Pipfile" ]; then
        echo "‚úì Projeto Python detectado"
        PROJECT_TYPE="python"
    elif [ -f "composer.json" ]; then
        echo "‚úì Projeto PHP detectado"
        PROJECT_TYPE="php"
    elif [ -f "Cargo.toml" ]; then
        echo "‚úì Projeto Rust detectado"
        PROJECT_TYPE="rust"
    elif [ -f "go.mod" ]; then
        echo "‚úì Projeto Go detectado"
        PROJECT_TYPE="go"
    else
        echo "‚ö†Ô∏è Tipo de projeto n√£o identificado automaticamente"
        PROJECT_TYPE="generic"
    fi
    echo ""
}

# An√°lise de arquivos desnecess√°rios
analyze_unnecessary_files() {
    echo -e "${YELLOW}üóëÔ∏è  ANALISANDO ARQUIVOS DESNECESS√ÅRIOS...${NC}"
    
    # Arquivos comuns desnecess√°rios
    unnecessary_patterns=(
        "*.log" "*.tmp" "*.temp" "*.bak" "*.backup" "*.old"
        ".DS_Store" "Thumbs.db" "desktop.ini"
        "*.pyc" "__pycache__" "*.pyo"
        "node_modules" ".npm" ".yarn"
        ".env.local" ".env.development" ".env.test"
        "*.swp" "*.swo" "*~"
        ".vscode" ".idea"
        "coverage" ".nyc_output"
        "dist" "build" ".next" ".nuxt"
    )
    
    found_unnecessary=0
    for pattern in "${unnecessary_patterns[@]}"; do
        files=$(find . -name "$pattern" -type f 2>/dev/null | head -10)
        dirs=$(find . -name "$pattern" -type d 2>/dev/null | head -5)
        
        if [ ! -z "$files" ] || [ ! -z "$dirs" ]; then
            if [ $found_unnecessary -eq 0 ]; then
                echo "‚ùå Arquivos/pastas desnecess√°rios encontrados:"
                found_unnecessary=1
            fi
            echo "   ‚Ä¢ $pattern"
            echo "$files" | sed 's/^/     /'
            echo "$dirs" | sed 's/^/     /'
        fi
    done
    
    if [ $found_unnecessary -eq 0 ]; then
        echo "‚úÖ Nenhum arquivo desnecess√°rio √≥bvio encontrado"
    fi
    echo ""
}

# An√°lise de seguran√ßa
security_analysis() {
    echo -e "${RED}üîí AN√ÅLISE DE SEGURAN√áA...${NC}"
    
    security_issues=0
    
    # Verificar arquivos .env expostos
    if [ -f ".env" ]; then
        echo "‚ö†Ô∏è  Arquivo .env encontrado - verifique se n√£o est√° sendo commitado"
        security_issues=$((security_issues + 1))
    fi
    
    # Procurar por senhas hardcoded
    hardcoded_secrets=$(grep -r -i -E "(password|senha|secret|token|key|api_key)" --include="*.js" --include="*.py" --include="*.php" --include="*.go" --include="*.rs" . 2>/dev/null | grep -v -E "(//|#|/\*)" | head -5)
    if [ ! -z "$hardcoded_secrets" ]; then
        echo "üö® Poss√≠veis segredos hardcoded encontrados:"
        echo "$hardcoded_secrets" | sed 's/^/   /'
        security_issues=$((security_issues + 1))
    fi
    
    # Verificar permiss√µes de arquivos suspeitas
    suspicious_perms=$(find . -type f -perm -o+w 2>/dev/null | grep -v ".git" | head -5)
    if [ ! -z "$suspicious_perms" ]; then
        echo "‚ö†Ô∏è  Arquivos com permiss√µes suspeitas (write para outros):"
        echo "$suspicious_perms" | sed 's/^/   /'
        security_issues=$((security_issues + 1))
    fi
    
    if [ $security_issues -eq 0 ]; then
        echo "‚úÖ Nenhum problema de seguran√ßa √≥bvio detectado"
    fi
    echo ""
}

# An√°lise espec√≠fica por linguagem
language_specific_analysis() {
    echo -e "${PURPLE}üîß AN√ÅLISE ESPEC√çFICA DA LINGUAGEM...${NC}"
    
    case $PROJECT_TYPE in
        "nodejs")
            nodejs_analysis
            ;;
        "python")
            python_analysis
            ;;
        "php")
            php_analysis
            ;;
        *)
            echo "‚úì An√°lise gen√©rica aplicada"
            ;;
    esac
    echo ""
}

# An√°lise Node.js
nodejs_analysis() {
    echo "üì¶ Analisando projeto Node.js..."
    
    # Verificar package.json
    if [ -f "package.json" ]; then
        # Depend√™ncias n√£o utilizadas
        if command -v npm &> /dev/null; then
            echo "üîç Verificando depend√™ncias n√£o utilizadas..."
            # Listar depend√™ncias que podem n√£o estar sendo usadas
            deps=$(jq -r '.dependencies | keys[]' package.json 2>/dev/null)
            for dep in $deps; do
                if ! grep -r "require.*$dep\|import.*$dep" --include="*.js" --include="*.ts" . &>/dev/null; then
                    echo "   ‚ö†Ô∏è  Depend√™ncia possivelmente n√£o utilizada: $dep"
                fi
            done
        fi
        
        # Verificar vulnerabilidades
        if command -v npm &> /dev/null; then
            echo "üõ°Ô∏è  Verificando vulnerabilidades..."
            npm audit --audit-level=moderate 2>/dev/null | grep -E "(found|vulnerabilities)" || echo "   ‚úÖ Nenhuma vulnerabilidade cr√≠tica encontrada"
        fi
    fi
    
    # Procurar por console.log em produ√ß√£o
    console_logs=$(grep -r "console\.log" --include="*.js" --include="*.ts" . 2>/dev/null | wc -l)
    if [ $console_logs -gt 0 ]; then
        echo "üêõ $console_logs console.log() encontrados - considere remover para produ√ß√£o"
    fi
}

# An√°lise Python
python_analysis() {
    echo "üêç Analisando projeto Python..."
    
    # Verificar imports n√£o utilizados
    python_files=$(find . -name "*.py" -type f)
    if [ ! -z "$python_files" ]; then
        echo "üîç Verificando poss√≠veis problemas no c√≥digo Python..."
        
        # Procurar por imports n√£o utilizados (b√°sico)
        for file in $python_files; do
            imports=$(grep "^import\|^from.*import" "$file" 2>/dev/null | head -3)
            if [ ! -z "$imports" ]; then
                # Verifica√ß√£o simples de uso
                unused_imports=$(echo "$imports" | while read import_line; do
                    module=$(echo "$import_line" | sed -E 's/^(import|from) ([a-zA-Z0-9_]+).*/\2/')
                    if ! grep -q "$module" "$file" 2>/dev/null | tail -n +2; then
                        echo "   ‚ö†Ô∏è  $file: poss√≠vel import n√£o utilizado - $import_line"
                    fi
                done)
                echo "$unused_imports"
            fi
        done
        
        # Verificar prints em arquivos Python
        print_statements=$(grep -r "print(" --include="*.py" . 2>/dev/null | wc -l)
        if [ $print_statements -gt 0 ]; then
            echo "üêõ $print_statements statements print() encontrados - considere usar logging"
        fi
    fi
}

# An√°lise PHP
php_analysis() {
    echo "üêò Analisando projeto PHP..."
    
    # Verificar var_dump, print_r
    debug_statements=$(grep -r -E "(var_dump|print_r|echo.*debug)" --include="*.php" . 2>/dev/null | wc -l)
    if [ $debug_statements -gt 0 ]; then
        echo "üêõ $debug_statements statements de debug encontrados"
    fi
    
    # Verificar por vulnerabilidades comuns
    sql_injection=$(grep -r -E "\\\$_(GET|POST|REQUEST).*\\\$" --include="*.php" . 2>/dev/null | wc -l)
    if [ $sql_injection -gt 0 ]; then
        echo "üö® Poss√≠veis vulnerabilidades de SQL injection encontradas: $sql_injection"
    fi
}

# An√°lise de performance
performance_analysis() {
    echo -e "${GREEN}‚ö° AN√ÅLISE DE PERFORMANCE...${NC}"
    
    # Tamanho dos arquivos
    large_files=$(find . -type f -size +1M ! -path "./.git/*" ! -path "./node_modules/*" 2>/dev/null)
    if [ ! -z "$large_files" ]; then
        echo "üìÅ Arquivos grandes encontrados (>1MB):"
        echo "$large_files" | while read file; do
            size=$(du -h "$file" | cut -f1)
            echo "   ‚Ä¢ $file ($size)"
        done
    else
        echo "‚úÖ Nenhum arquivo muito grande encontrado"
    fi
    
    # Contar linhas de c√≥digo
    code_files=$(find . -type f \( -name "*.js" -o -name "*.py" -o -name "*.php" -o -name "*.go" -o -name "*.rs" -o -name "*.java" -o -name "*.cpp" -o -name "*.c" \) ! -path "./.git/*" ! -path "./node_modules/*" 2>/dev/null)
    if [ ! -z "$code_files" ]; then
        total_lines=$(wc -l $code_files 2>/dev/null | tail -1 | awk '{print $1}')
        echo "üìä Total de linhas de c√≥digo: $total_lines"
    fi
    echo ""
}

# Sugest√µes de otimiza√ß√£o
optimization_suggestions() {
    echo -e "${BLUE}üí° SUGEST√ïES DE OTIMIZA√á√ÉO...${NC}"
    
    # Verificar se existe .gitignore
    if [ ! -f ".gitignore" ]; then
        echo "üìù Criar arquivo .gitignore para ignorar arquivos desnecess√°rios"
    fi
    
    # Verificar se existe README
    if [ ! -f "README.md" ] && [ ! -f "README.txt" ]; then
        echo "üìö Adicionar arquivo README com documenta√ß√£o do projeto"
    fi
    
    # Sugest√µes espec√≠ficas por tipo de projeto
    case $PROJECT_TYPE in
        "nodejs")
            if [ ! -f ".nvmrc" ]; then
                echo "üîß Considere adicionar arquivo .nvmrc para fixar vers√£o do Node.js"
            fi
            if [ ! -f "package-lock.json" ] && [ ! -f "yarn.lock" ]; then
                echo "üîí Execute npm install para gerar package-lock.json"
            fi
            ;;
        "python")
            if [ ! -f "requirements.txt" ] && [ ! -f "pyproject.toml" ]; then
                echo "üì¶ Gerar requirements.txt com: pip freeze > requirements.txt"
            fi
            if [ ! -f ".python-version" ]; then
                echo "üêç Considere especificar vers√£o do Python em .python-version"
            fi
            ;;
    esac
    
    echo "üöÄ Considere configurar CI/CD para automatizar testes e deploys"
    echo "üîç Use linters espec√≠ficos da linguagem para melhor qualidade de c√≥digo"
    echo ""
}

# Resumo executivo
executive_summary() {
    echo -e "${GREEN}üìã RESUMO EXECUTIVO${NC}"
    echo "==================="
    
    # Contar arquivos por tipo
    total_files=$(find . -type f ! -path "./.git/*" | wc -l)
    code_files=$(find . -type f \( -name "*.js" -o -name "*.py" -o -name "*.php" -o -name "*.go" -o -name "*.rs" \) ! -path "./.git/*" ! -path "./node_modules/*" | wc -l)
    
    echo "üìä Estat√≠sticas do projeto:"
    echo "   ‚Ä¢ Total de arquivos: $total_files"
    echo "   ‚Ä¢ Arquivos de c√≥digo: $code_files"
    echo "   ‚Ä¢ Tipo de projeto: $PROJECT_TYPE"
    
    echo ""
    echo "üéØ A√ß√µes recomendadas:"
    echo "   1. Revisar e remover arquivos desnecess√°rios identificados"
    echo "   2. Corrigir problemas de seguran√ßa encontrados"
    echo "   3. Implementar sugest√µes de otimiza√ß√£o"
    echo "   4. Configurar ferramentas de linting autom√°tico"
    echo "   5. Adicionar testes automatizados se n√£o existirem"
    echo ""
}

# Comando para limpeza autom√°tica
cleanup_command() {
    echo -e "${YELLOW}üßπ COMANDO DE LIMPEZA AUTOM√ÅTICA${NC}"
    echo "=================================="
    echo ""
    echo "Para executar limpeza autom√°tica, execute:"
    echo ""
    echo -e "${GREEN}# Remover arquivos tempor√°rios comuns${NC}"
    echo "find . -name '*.tmp' -o -name '*.temp' -o -name '*.log' -o -name '*.bak' | xargs rm -f"
    echo ""
    echo -e "${GREEN}# Remover caches Python${NC}"
    echo "find . -name '__pycache__' -type d -exec rm -rf {} + 2>/dev/null || true"
    echo "find . -name '*.pyc' -delete"
    echo ""
    echo -e "${GREEN}# Remover arquivos do sistema${NC}"
    echo "find . -name '.DS_Store' -o -name 'Thumbs.db' -o -name 'desktop.ini' | xargs rm -f"
    echo ""
    echo -e "${RED}‚ö†Ô∏è  ATEN√á√ÉO: Revise antes de executar os comandos de limpeza!${NC}"
    echo ""
}

# Executar todas as an√°lises
main() {
    detect_project_type
    analyze_unnecessary_files
    security_analysis
    language_specific_analysis
    performance_analysis
    optimization_suggestions
    executive_summary
    cleanup_command
    
    echo -e "${GREEN}‚úÖ AN√ÅLISE CONCLU√çDA!${NC}"
    echo "üí° Execute este script regularmente para manter seu projeto otimizado."
}

# Verificar se est√° sendo executado como script principal
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi