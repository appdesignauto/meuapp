#!/usr/bin/env node

const http = require('http');
const https = require('https');

/**
 * Script de valida√ß√£o para testar rotas ap√≥s limpeza de duplica√ß√µes
 * Testa se as rotas est√£o funcionando corretamente sem conflitos
 */

const BASE_URL = process.env.BASE_URL || 'http://localhost:3000';
const ADMIN_TOKEN = process.env.ADMIN_TOKEN; // Se necess√°rio para autentica√ß√£o

const ROUTES_TO_TEST = [
  {
    path: '/api/admin/subscription-users',
    method: 'GET',
    requiresAuth: true,
    expectedStatus: [200, 401] // 200 se autenticado, 401 se n√£o
  },
  {
    path: '/api/admin/subscription-metrics',
    method: 'GET',
    requiresAuth: true,
    expectedStatus: [200, 401]
  },
  {
    path: '/api/subscription-settings',
    method: 'GET',
    requiresAuth: true,
    expectedStatus: [200, 401]
  }
];

// Fun√ß√£o para fazer requisi√ß√µes HTTP
function makeRequest(url, options = {}) {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https') ? https : http;
    
    const req = client.request(url, options, (res) => {
      let data = '';
      
      res.on('data', (chunk) => {
        data += chunk;
      });
      
      res.on('end', () => {
        resolve({
          statusCode: res.statusCode,
          headers: res.headers,
          body: data,
          url: url
        });
      });
    });
    
    req.on('error', (error) => {
      reject(error);
    });
    
    req.end();
  });
}

// Testar uma rota espec√≠fica
async function testRoute(route) {
  console.log(`üîç Testando: ${route.method} ${route.path}`);
  
  const url = `${BASE_URL}${route.path}`;
  const options = {
    method: route.method,
    headers: {
      'Content-Type': 'application/json'
    }
  };
  
  // Adicionar token de admin se necess√°rio
  if (route.requiresAuth && ADMIN_TOKEN) {
    options.headers['Authorization'] = `Bearer ${ADMIN_TOKEN}`;
  }
  
  try {
    const response = await makeRequest(url, options);
    
    const isExpectedStatus = route.expectedStatus.includes(response.statusCode);
    const status = isExpectedStatus ? '‚úÖ' : '‚ùå';
    
    console.log(`${status} Status: ${response.statusCode}`);
    
    // Analisar resposta
    if (response.statusCode === 200) {
      try {
        const json = JSON.parse(response.body);
        if (json.success) {
          console.log(`   ‚úÖ Resposta v√°lida recebida`);
          
          // Valida√ß√µes espec√≠ficas por rota
          if (route.path.includes('subscription-users') && json.users) {
            console.log(`   üìä Usu√°rios encontrados: ${json.total || json.users.length}`);
          }
          
          if (route.path.includes('subscription-metrics') && json.metrics) {
            console.log(`   üìä M√©tricas: ${Object.keys(json.metrics).length} campos`);
          }
          
          if (route.path.includes('subscription-settings') && json.settings) {
            console.log(`   ‚öôÔ∏è  Configura√ß√µes carregadas`);
          }
        } else {
          console.log(`   ‚ö†Ô∏è  Resposta indica erro: ${json.error || 'Erro desconhecido'}`);
        }
      } catch (parseError) {
        console.log(`   ‚ö†Ô∏è  Resposta n√£o √© JSON v√°lido`);
      }
    } else if (response.statusCode === 401) {
      console.log(`   üîí Autentica√ß√£o necess√°ria (comportamento esperado)`);
    } else if (response.statusCode === 404) {
      console.log(`   ‚ùå Rota n√£o encontrada - poss√≠vel problema de configura√ß√£o`);
    } else {
      console.log(`   ‚ö†Ô∏è  Status inesperado: ${response.statusCode}`);
    }
    
    return {
      route: route.path,
      success: isExpectedStatus,
      statusCode: response.statusCode,
      hasValidResponse: response.statusCode === 200
    };
    
  } catch (error) {
    console.log(`‚ùå Erro na requisi√ß√£o: ${error.message}`);
    return {
      route: route.path,
      success: false,
      error: error.message
    };
  }
}

// Verificar se servidor est√° rodando
async function checkServerHealth() {
  console.log('üè• Verificando sa√∫de do servidor...');
  
  try {
    const response = await makeRequest(`${BASE_URL}/health`);
    if (response.statusCode === 200) {
      console.log('‚úÖ Servidor est√° respondendo');
      return true;
    }
  } catch (error) {
    // Tentar rota raiz se /health n√£o existir
    try {
      const response = await makeRequest(BASE_URL);
      if (response.statusCode < 500) {
        console.log('‚úÖ Servidor est√° respondendo');
        return true;
      }
    } catch (rootError) {
      console.log('‚ùå Servidor n√£o est√° respondendo');
      console.log(`   Erro: ${error.message}`);
      return false;
    }
  }
  
  return false;
}

// Verificar logs por conflitos
function checkForRouteConflicts() {
  console.log('üîç Verificando por conflitos de rota...');
  
  const fs = require('fs');
  const path = require('path');
  
  const logPatterns = [
    'duplicate route',
    'route conflict',
    'multiple handlers',
    'Cannot set headers after they are sent'
  ];
  
  // Verificar arquivos de log se existirem
  const logPaths = [
    'server.log',
    'error.log',
    'npm-debug.log',
    'console.log'
  ];
  
  let conflictsFound = false;
  
  logPaths.forEach(logPath => {
    if (fs.existsSync(logPath)) {
      const content = fs.readFileSync(logPath, 'utf8');
      
      logPatterns.forEach(pattern => {
        if (content.toLowerCase().includes(pattern.toLowerCase())) {
          console.log(`‚ö†Ô∏è  Poss√≠vel conflito encontrado em ${logPath}: ${pattern}`);
          conflictsFound = true;
        }
      });
    }
  });
  
  if (!conflictsFound) {
    console.log('‚úÖ Nenhum conflito de rota detectado nos logs');
  }
  
  return !conflictsFound;
}

// Gerar relat√≥rio de valida√ß√£o
function generateValidationReport(results) {
  const totalTests = results.length;
  const successfulTests = results.filter(r => r.success).length;
  const workingRoutes = results.filter(r => r.hasValidResponse).length;
  
  const report = `
RELAT√ìRIO DE VALIDA√á√ÉO P√ìS-LIMPEZA
===================================

Data: ${new Date().toLocaleString('pt-BR')}
Servidor: ${BASE_URL}

RESUMO:
- Testes executados: ${totalTests}
- Testes bem-sucedidos: ${successfulTests}
- Rotas funcionais: ${workingRoutes}
- Taxa de sucesso: ${Math.round((successfulTests / totalTests) * 100)}%

DETALHES POR ROTA:
${results.map(result => `
- ${result.route}:
  Status: ${result.success ? '‚úÖ OK' : '‚ùå FALHA'}
  C√≥digo: ${result.statusCode || 'N/A'}
  ${result.error ? `Erro: ${result.error}` : ''}
`).join('')}

DIAGN√ìSTICO:
${successfulTests === totalTests ? 
  '‚úÖ Todas as rotas est√£o funcionando corretamente' : 
  '‚ö†Ô∏è  Algumas rotas podem precisar de aten√ß√£o'
}

RECOMENDA√á√ïES:
${workingRoutes === 0 ? 
  'üîß Verifique se o servidor est√° rodando e se as rotas est√£o configuradas' :
  workingRoutes < totalTests ?
  'üîß Verifique autentica√ß√£o e configura√ß√£o das rotas com falha' :
  '‚úÖ Sistema funcionando normalmente'
}
`;

  require('fs').writeFileSync('validation-report.txt', report);
  console.log('\nüìã Relat√≥rio de valida√ß√£o salvo em: validation-report.txt');
}

// Fun√ß√£o principal
async function main() {
  console.log('üöÄ Iniciando valida√ß√£o das rotas...\n');
  
  // Verificar se servidor est√° rodando
  const serverHealthy = await checkServerHealth();
  if (!serverHealthy) {
    console.log('‚ùå Servidor n√£o est√° respondendo. Inicie o servidor e tente novamente.');
    process.exit(1);
  }
  
  console.log(''); // Linha em branco
  
  // Testar cada rota
  const results = [];
  for (const route of ROUTES_TO_TEST) {
    const result = await testRoute(route);
    results.push(result);
    console.log(''); // Linha em branco entre testes
  }
  
  // Verificar conflitos
  checkForRouteConflicts();
  
  // Gerar relat√≥rio
  generateValidationReport(results);
  
  // Resumo final
  const successCount = results.filter(r => r.success).length;
  const totalCount = results.length;
  
  console.log(`\nüìä RESULTADO FINAL:`);
  console.log(`‚úÖ ${successCount}/${totalCount} rotas validadas com sucesso`);
  
  if (successCount === totalCount) {
    console.log('üéâ Limpeza de rotas bem-sucedida! Sistema funcionando normalmente.');
  } else {
    console.log('‚ö†Ô∏è  Algumas rotas podem precisar de aten√ß√£o. Verifique o relat√≥rio.');
  }
  
  console.log('\nüí° PR√ìXIMOS PASSOS:');
  console.log('1. Teste o dashboard administrativo manualmente');
  console.log('2. Monitore logs por alguns minutos');
  console.log('3. Se tudo estiver OK, remova os backups');
}

// Executar se chamado diretamente
if (require.main === module) {
  main().catch(error => {
    console.error('‚ùå Erro durante valida√ß√£o:', error);
    process.exit(1);
  });
}

module.exports = { testRoute, checkServerHealth };