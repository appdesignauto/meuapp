#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Script para remover rotas duplicadas do sistema de assinatura
 * Remove duplicaÃ§Ãµes em server/index.ts, server/routes.ts e scripts de correÃ§Ã£o
 */

const BACKUP_DIR = 'backup-routes-cleanup';
const FILES_TO_CLEAN = [
  'server/index.ts',
  'server/routes.ts'
];

const SCRIPTS_TO_REMOVE = [
  'fix-subscription-endpoint-final.js',
  'fix-subscription-endpoint.js',
  'test-subscription-routes.js'
];

// Criar diretÃ³rio de backup
function createBackup() {
  console.log('ğŸ“¦ Criando backup dos arquivos...');
  
  if (!fs.existsSync(BACKUP_DIR)) {
    fs.mkdirSync(BACKUP_DIR, { recursive: true });
  }
  
  FILES_TO_CLEAN.forEach(file => {
    if (fs.existsSync(file)) {
      const backupPath = path.join(BACKUP_DIR, path.basename(file));
      fs.copyFileSync(file, backupPath);
      console.log(`âœ… Backup criado: ${backupPath}`);
    }
  });
}

// Remover rotas duplicadas do server/index.ts
function cleanServerIndex() {
  console.log('ğŸ§¹ Limpando server/index.ts...');
  
  const filePath = 'server/index.ts';
  if (!fs.existsSync(filePath)) {
    console.log('âš ï¸  server/index.ts nÃ£o encontrado');
    return;
  }
  
  let content = fs.readFileSync(filePath, 'utf8');
  
  // Remover rota duplicada de subscription-users (linha 208)
  const duplicateRoutePattern = /\/\/ Rota duplicada - REMOVER[\s\S]*?app\.get\('\/api\/admin\/subscription-users'[\s\S]*?}\);/g;
  content = content.replace(duplicateRoutePattern, '');
  
  // Remover comentÃ¡rios de debug antigos
  content = content.replace(/\/\/ DEBUG:.*$/gm, '');
  content = content.replace(/\/\/ TEMP:.*$/gm, '');
  
  // Limpar linhas vazias excessivas
  content = content.replace(/\n\n\n+/g, '\n\n');
  
  fs.writeFileSync(filePath, content);
  console.log('âœ… server/index.ts limpo');
}

// Consolidar rotas no server/routes.ts
function cleanServerRoutes() {
  console.log('ğŸ§¹ Consolidando server/routes.ts...');
  
  const filePath = 'server/routes.ts';
  if (!fs.existsSync(filePath)) {
    console.log('âš ï¸  server/routes.ts nÃ£o encontrado');
    return;
  }
  
  let content = fs.readFileSync(filePath, 'utf8');
  
  // Template das rotas consolidadas (mantendo apenas as versÃµes funcionais)
  const consolidatedRoutes = `
// =================================
// SUBSCRIPTION MANAGEMENT ROUTES
// =================================

// Listar usuÃ¡rios com assinatura ativa
app.get('/api/admin/subscription-users', isAdmin, async (req, res) => {
  try {
    const users = await prisma.user.findMany({
      where: {
        OR: [
          { subscription_status: 'active' },
          { subscription_status: 'trialing' }
        ]
      },
      select: {
        id: true,
        email: true,
        subscription_status: true,
        subscription_plan: true,
        subscription_start_date: true,
        subscription_end_date: true,
        createdAt: true
      },
      orderBy: {
        subscription_start_date: 'desc'
      }
    });

    res.json({
      success: true,
      users: users,
      total: users.length
    });
  } catch (error) {
    console.error('Erro ao buscar usuÃ¡rios de assinatura:', error);
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor'
    });
  }
});

// MÃ©tricas de assinatura para dashboard
app.get('/api/admin/subscription-metrics', isAdmin, async (req, res) => {
  try {
    const [activeUsers, trialingUsers, totalRevenue, recentSignups] = await Promise.all([
      prisma.user.count({
        where: { subscription_status: 'active' }
      }),
      prisma.user.count({
        where: { subscription_status: 'trialing' }
      }),
      prisma.user.aggregate({
        where: { subscription_status: 'active' },
        _sum: { subscription_amount: true }
      }),
      prisma.user.count({
        where: {
          subscription_start_date: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Ãšltimos 7 dias
          }
        }
      })
    ]);

    res.json({
      success: true,
      metrics: {
        activeSubscriptions: activeUsers,
        trialSubscriptions: trialingUsers,
        totalUsers: activeUsers + trialingUsers,
        monthlyRevenue: totalRevenue._sum.subscription_amount || 0,
        recentSignups: recentSignups
      }
    });
  } catch (error) {
    console.error('Erro ao buscar mÃ©tricas:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao carregar mÃ©tricas'
    });
  }
});

// ConfiguraÃ§Ãµes de assinatura (apenas versÃ£o de produÃ§Ã£o)
app.get('/api/subscription-settings', isAdmin, async (req, res) => {
  try {
    const settings = {
      plans: [
        {
          id: 'basic',
          name: 'Plano BÃ¡sico',
          price: 29.90,
          features: ['Acesso completo', 'Suporte por email']
        },
        {
          id: 'premium',
          name: 'Plano Premium',
          price: 49.90,
          features: ['Acesso completo', 'Suporte prioritÃ¡rio', 'Recursos avanÃ§ados']
        }
      ],
      trialDays: 7,
      currencies: ['BRL', 'USD']
    };

    res.json({
      success: true,
      settings: settings
    });
  } catch (error) {
    console.error('Erro ao buscar configuraÃ§Ãµes:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao carregar configuraÃ§Ãµes'
    });
  }
});
`;

  // Remover todas as rotas de assinatura existentes
  content = content.replace(/\/\/ SUBSCRIPTION.*?(?=\/\/|app\.|$)/gs, '');
  content = content.replace(/app\.get\('\/api\/admin\/subscription-users'[\s\S]*?}\);/g, '');
  content = content.replace(/app\.get\('\/api\/admin\/subscription-metrics'[\s\S]*?}\);/g, '');
  content = content.replace(/app\.get\('\/api\/subscription-settings'[\s\S]*?}\);/g, '');
  content = content.replace(/app\.get\('\/api\/test\/subscription-settings'[\s\S]*?}\);/g, '');
  
  // Adicionar rotas consolidadas no final, antes da exportaÃ§Ã£o
  const exportIndex = content.lastIndexOf('export');
  if (exportIndex !== -1) {
    content = content.slice(0, exportIndex) + consolidatedRoutes + '\n\n' + content.slice(exportIndex);
  } else {
    content += consolidatedRoutes;
  }
  
  // Limpar linhas vazias excessivas
  content = content.replace(/\n\n\n+/g, '\n\n');
  
  fs.writeFileSync(filePath, content);
  console.log('âœ… server/routes.ts consolidado');
}

// Remover scripts de correÃ§Ã£o obsoletos
function removeObsoleteScripts() {
  console.log('ğŸ—‘ï¸  Removendo scripts obsoletos...');
  
  SCRIPTS_TO_REMOVE.forEach(script => {
    if (fs.existsSync(script)) {
      // Fazer backup antes de remover
      const backupPath = path.join(BACKUP_DIR, script);
      fs.copyFileSync(script, backupPath);
      fs.unlinkSync(script);
      console.log(`âœ… Removido: ${script} (backup em ${backupPath})`);
    } else {
      console.log(`âš ï¸  ${script} nÃ£o encontrado`);
    }
  });
}

// Verificar integridade apÃ³s limpeza
function verifyCleanup() {
  console.log('ğŸ” Verificando integridade...');
  
  const issues = [];
  
  // Verificar se nÃ£o hÃ¡ rotas duplicadas restantes
  FILES_TO_CLEAN.forEach(file => {
    if (fs.existsSync(file)) {
      const content = fs.readFileSync(file, 'utf8');
      
      // Contar ocorrÃªncias de cada endpoint
      const subscriptionUsersCount = (content.match(/\/api\/admin\/subscription-users/g) || []).length;
      const subscriptionMetricsCount = (content.match(/\/api\/admin\/subscription-metrics/g) || []).length;
      const subscriptionSettingsCount = (content.match(/\/api\/subscription-settings/g) || []).length;
      
      if (subscriptionUsersCount > 1) {
        issues.push(`${file}: ${subscriptionUsersCount} rotas subscription-users`);
      }
      if (subscriptionMetricsCount > 1) {
        issues.push(`${file}: ${subscriptionMetricsCount} rotas subscription-metrics`);
      }
      if (subscriptionSettingsCount > 1) {
        issues.push(`${file}: ${subscriptionSettingsCount} rotas subscription-settings`);
      }
    }
  });
  
  if (issues.length > 0) {
    console.log('âš ï¸  PossÃ­veis duplicaÃ§Ãµes restantes:');
    issues.forEach(issue => console.log(`   - ${issue}`));
  } else {
    console.log('âœ… Nenhuma duplicaÃ§Ã£o encontrada');
  }
}

// Gerar relatÃ³rio de limpeza
function generateReport() {
  const report = `
RELATÃ“RIO DE LIMPEZA DE ROTAS DUPLICADAS
========================================

Data: ${new Date().toLocaleString('pt-BR')}

AÃ‡Ã•ES EXECUTADAS:
âœ… Backup criado em: ${BACKUP_DIR}/
âœ… Rotas duplicadas removidas de server/index.ts
âœ… Rotas consolidadas em server/routes.ts
âœ… Scripts obsoletos removidos

ROTAS MANTIDAS (versÃµes funcionais):
- GET /api/admin/subscription-users (com middleware isAdmin)
- GET /api/admin/subscription-metrics (com middleware isAdmin)
- GET /api/subscription-settings (com middleware isAdmin)

SCRIPTS REMOVIDOS:
${SCRIPTS_TO_REMOVE.map(script => `- ${script}`).join('\n')}

PRÃ“XIMOS PASSOS:
1. Testar as rotas no dashboard administrativo
2. Verificar se o middleware SPA nÃ£o estÃ¡ mais interceptando
3. Monitorar performance das consultas
4. Remover backup apÃ³s confirmaÃ§Ã£o de funcionamento

Para reverter as mudanÃ§as:
cp ${BACKUP_DIR}/* ./
`;

  fs.writeFileSync('cleanup-report.txt', report);
  console.log('\nğŸ“‹ RelatÃ³rio salvo em: cleanup-report.txt');
}

// Executar limpeza
async function main() {
  console.log('ğŸš€ Iniciando limpeza de rotas duplicadas...\n');
  
  try {
    createBackup();
    cleanServerIndex();
    cleanServerRoutes();
    removeObsoleteScripts();
    verifyCleanup();
    generateReport();
    
    console.log('\nâœ… Limpeza concluÃ­da com sucesso!');
    console.log('ğŸ”„ Reinicie o servidor para aplicar as mudanÃ§as');
    console.log('ğŸ“‹ Verifique o relatÃ³rio em: cleanup-report.txt');
    
  } catch (error) {
    console.error('âŒ Erro durante a limpeza:', error);
    console.log('ğŸ”„ Restaure os backups se necessÃ¡rio');
  }
}

if (require.main === module) {
  main();
}